{
    "version": "https://jsonfeed.org/version/1",
    "title": "Sidey",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Simple and minimalistic jekyll blogging theme.",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author": "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}",
    
"items": [
    
        {
            "id": "http://localhost:4000/2020/08/30/what-is-happening-with-my-block",
            "title": "What is Happening With my Block?",
            "summary": null,
            "content_text": "Do you know which tests are going to pass and which tests are going to fail in this test file?require \"minitest/autorun\"class TestBlocks &lt; Minitest::Test  def setup    @values = [\"a\", \"b\", \"c\", \"d\"]  end    def test_passing_a_block_with_do    assert @values.all? do |value|      false    end  end    def test_passing_a_block_with_do_surround_by_parentheses    assert(@values.all? do |value|      false    end)  end    def test_passing_a_block_with_braces    assert @values.all? { |value| false }  endendHow do you do in your code base? If you do like in test_passing_a_block_with_do it is bad news.test_passing_a_block_with_do is the only one which is going to pass, but why? I know you know, assert receives @values.all? do |value| as a block, then it thinks this block is true and that’s it. If you thought that, you’re almost right. Let’s see what is assert.# https://github.com/seattlerb/minitest/blob/6257210b7accfeb218b4388aaa36d3d45c5c41a5/lib/minitest/assertions.rb#L178def assert test, msg = nil  self.assertions += 1  unless test then    msg ||= \"Expected #{mu_pp test} to be truthy.\"    msg = msg.call if Proc === msg    raise Minitest::Assertion, msg  end  trueendSo, is test a Proc? What do you think?After debugging this method I know that test is true. Why is it true? The class is TrueClass, so it is a proper true. What is happening here?What is msg then? msg is the Proc then, right?(byebug) msgnilmsg is nil. Okay, it got the default value. Where is my block then? Well, there is only one place left now.(byebug) yieldfalseOk, false. The block I’m passing is returning false, is that the reason? If I change to:def test_passing_a_block_with_do  assert @values.all? do |value|    \"hello, world!\"  endendThen I have:(byebug) yield\"hello, world!\"Ahhhh, that was it.A mindful programmer would figure that out at first saw, there is no reason to think that the whole collection.all? do...end is going to be a single argument. However, I think it’s pretty easy to miss that, have you got it at first glance?",
            "content_html": "<p>Do you know which tests are going to pass and which tests are going to fail in this test file?</p><pre><code class=\"language-ruby\">require \"minitest/autorun\"class TestBlocks &lt; Minitest::Test  def setup    @values = [\"a\", \"b\", \"c\", \"d\"]  end    def test_passing_a_block_with_do    assert @values.all? do |value|      false    end  end    def test_passing_a_block_with_do_surround_by_parentheses    assert(@values.all? do |value|      false    end)  end    def test_passing_a_block_with_braces    assert @values.all? { |value| false }  endend</code></pre><p>How do you do in your code base? If you do like in <code>test_passing_a_block_with_do</code> it is bad news.</p><p><code>test_passing_a_block_with_do</code> is the only one which is going to pass, but why? I know you know, <code>assert</code> receives <code>@values.all? do |value|</code> as a block, then it thinks this block is true and that’s it. If you thought that, you’re almost right. Let’s see what is <code>assert</code>.</p><pre><code class=\"language-ruby\"># https://github.com/seattlerb/minitest/blob/6257210b7accfeb218b4388aaa36d3d45c5c41a5/lib/minitest/assertions.rb#L178def assert test, msg = nil  self.assertions += 1  unless test then    msg ||= \"Expected #{mu_pp test} to be truthy.\"    msg = msg.call if Proc === msg    raise Minitest::Assertion, msg  end  trueend</code></pre><p>So, is <code>test</code> a <code>Proc</code>? What do you think?</p><p>After debugging this method I know that <code>test</code> is <code>true</code>. Why is it <code>true</code>? The class is <code>TrueClass</code>, so it is a proper <code>true</code>. What is happening here?</p><p>What is <code>msg</code> then? <code>msg</code> is the <code>Proc</code> then, right?</p><pre><code class=\"language-ruby\">(byebug) msgnil</code></pre><p><code>msg</code> is <code>nil</code>. Okay, it got the default value. Where is my block then? Well, there is only one place left now.</p><pre><code class=\"language-ruby\">(byebug) yieldfalse</code></pre><p>Ok, <code>false</code>. The block I’m passing is returning <code>false</code>, is that the reason? If I change to:</p><pre><code class=\"language-ruby\">def test_passing_a_block_with_do  assert @values.all? do |value|    \"hello, world!\"  endend</code></pre><p>Then I have:</p><pre><code class=\"language-ruby\">(byebug) yield\"hello, world!\"</code></pre><p>Ahhhh, that was it.</p><p>A mindful programmer would figure that out at first saw, there is no reason to think that the whole <code>collection.all? do...end</code> is going to be a single argument. However, I think it’s pretty easy to miss that, have you got it at first glance?</p>",
            "url": "http://localhost:4000/2020/08/30/what-is-happening-with-my-block",
            
            
            
            
            
            "date_published": "2020-08-30T00:00:00+01:00",
            "date_modified": "2020-08-30T00:00:00+01:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        }
    
    ]
}