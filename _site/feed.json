{
    "version": "https://jsonfeed.org/version/1",
    "title": "Matheus's Blog",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Opinions are my own",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Matheus Silva",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://localhost:4000/2020/08/31/como-iterar-em-ruby",
            "title": "Como Iterar em Ruby?",
            "summary": null,
            "content_text": "Primeiras ImpressõesCaso seja um iniciante na programação, estará muito acostumado com isso:for(int i = 0; i &lt;= 10; i++) {        printf(\"%d\", i);}Caso seja um pouco mais ousado, provavelmente já terá encontrado isso:elements.forEach(function(e) {  e.addClass('active');});Para quem conhece só a primeira forma de iterar, o choque com as iterações em Ruby será maior. Para quem já conhece a segunda forma (que existe em outras linguagens de forma semelhante, mas não idêntica) não será tão impactante.Aqui está a forma mais simples de iterar em Ruby:users.each do |user|  user.notify!endEssa forma, não é a mais elegante, porém é bastante encontrada. Existe outra forma menos elegante, que é esta:for i in 0..10  puts iendMesmo essa forma, que pelo menos encontramos a palavra for no meio, é bem diferente do que encontramos em outras linguagens. Minhas primeiras dúvidas quando vi essa iteração pela primeira vez foram:  Como faço se eu não quero incrementar de um em um?  Onde está a condição?  Como que eu itero do maior para o menor?Esta forma de iterar é deveras limitada, você não consegue tudo com ela, porém, a linguagem Ruby é poderosa, elegante, carismática e bela, você consegue implementar o que quer de uma forma ou de outra. No entretanto, o que eu percebi nos meus primeiros dias usando Ruby, é que geralmente não precisamos iterar de uma forma tão imperativa, na verdade, podemos alcançar o que queremos de outras formas.Oito tons de iteraçãoforfor i in 0..10  puts iendtimes2.times { \"hello friend\" }3.times { |index| puts index }É nessa forma que as pessoas se apaixonam por Ruby, você está escrevendo um texto corrido praticamente. Quer executar alguma coisa quatro vezes? Ótimo, escreva 4.times { execute_your_beautiful_code }.eachMuitas pessoas conhecem esta forma de outras linguagens, você tem alguns elementos dentro de uma coleção e você quer iterar sobre eles.students.each { |student| student.call_for_re_enrollment! }whileAqui você está livre para fazer o que quiser. Também temos essa opção em outras linguagens.i = 0while i &lt; 10 do  puts i  i += 2 # pulando de dois em doisendEssa opção é um pouco mais verbosa comparada com as outras, mas tem seus usos.Aqui está um exemplo mais real de como essa iteração pode ser usada.waiting_seconds = 0while stack.deploying?  logger.info(\"Waiting for deployment to complete\")  sleep waiting_seconds += 1enduntilComo disse, essa linguagem é linda. until é o contrário do while, ela executará enquanto a condição for false.until me.tired?  me.work_hardendloopSe quiser ir para o infinito e além, use o loop para criar um loop infinito.loop do  # your code here..  break if your_conditionenduptoMuito claro o que isso faz pelo nome, expõe lindamente o que queremos, ir de um índice até outro, existe uma variação dessa forma que será o próximo tópico.1.upto(10) { |i| puts index }downto10.downto(1) { |i| puts index }Usando Iterações como se Você Tivesse Nascido para IssoEnumerableLeia a documentação do Enumerable. Veja os métodos que o módulo oferece, brinque com eles no terminal iterativo (IRB). É aqui que você elevará suas habilidades para se tornar o grande programador que o mundo quer conhecer. Com esse módulo você não somente ira iterar sobre listas, mas poderá transformá-las, reduzí-las, fazer perguntas, filtrar etc.Iterando sobre uma fatia[1, 2, 3, 4, 5, 6].each_slice(3) { |slice| puts slice }Transformando[1, 2, 3, 4].map { |number| { number.to_s =&gt; number ** 2 } }Reduzindo[1, 2, 3, 4].reduce({ numbers: [] }) do |hash, number|  hash[:numbers] &lt;&lt; number  hashendQuestionando[2, 4, 6, 8, 10].all?(&amp;:even?)[1, 4, 3, 8, 9].select(&amp;:even?)Próximos passosEssa pergunta no Stack Overflow para quem ficou com dúvidas sobre os últimos exemplos: What does map(&amp;:name) mean in Ruby?.Leia a documentação da classe Array, você encontrá vários métodos que você já viu no módulo Enumerable, porém encontrá muita coisa nova também: Array.",
            "content_html": "<h2 id=\"primeiras-impressões\">Primeiras Impressões</h2><p>Caso seja um iniciante na programação, estará muito acostumado com isso:</p><pre><code class=\"language-c\">for(int i = 0; i &lt;= 10; i++) {        printf(\"%d\", i);}</code></pre><p>Caso seja um pouco mais ousado, provavelmente já terá encontrado isso:</p><pre><code class=\"language-javascript\">elements.forEach(function(e) {  e.addClass('active');});</code></pre><p>Para quem conhece só a primeira forma de iterar, o choque com as iterações em Ruby será maior. Para quem já conhece a segunda forma (que existe em outras linguagens de forma semelhante, mas não idêntica) não será tão impactante.</p><p>Aqui está a forma mais simples de iterar em Ruby:</p><pre><code class=\"language-ruby\">users.each do |user|  user.notify!end</code></pre><p>Essa forma, não é a mais elegante, porém é bastante encontrada. Existe outra forma menos elegante, que é esta:</p><pre><code class=\"language-ruby\">for i in 0..10  puts iend</code></pre><p>Mesmo essa forma, que pelo menos encontramos a palavra <code>for</code> no meio, é bem diferente do que encontramos em outras linguagens. Minhas primeiras dúvidas quando vi essa iteração pela primeira vez foram:</p><ul>  <li>Como faço se eu não quero incrementar de um em um?</li>  <li>Onde está a condição?</li>  <li>Como que eu itero do maior para o menor?</li></ul><p>Esta forma de iterar é deveras limitada, você não consegue tudo com ela, porém, a linguagem Ruby é poderosa, elegante, carismática e bela, você consegue implementar o que quer de uma forma ou de outra. No entretanto, o que eu percebi nos meus primeiros dias usando Ruby, é que geralmente não precisamos iterar de uma forma tão imperativa, na verdade, podemos alcançar o que queremos de outras formas.</p><h2 id=\"oito-tons-de-iteração\">Oito tons de iteração</h2><h3 id=\"for\">for</h3><pre><code class=\"language-ruby\">for i in 0..10  puts iend</code></pre><h3 id=\"times\">times</h3><pre><code class=\"language-ruby\">2.times { \"hello friend\" }</code></pre><pre><code class=\"language-ruby\">3.times { |index| puts index }</code></pre><p>É nessa forma que as pessoas se apaixonam por Ruby, você está escrevendo um texto corrido praticamente. Quer executar alguma coisa quatro vezes? Ótimo, escreva <code>4.times { execute_your_beautiful_code }</code>.</p><h3 id=\"each\">each</h3><p>Muitas pessoas conhecem esta forma de outras linguagens, você tem alguns elementos dentro de uma coleção e você quer iterar sobre eles.</p><pre><code class=\"language-ruby\">students.each { |student| student.call_for_re_enrollment! }</code></pre><h3 id=\"while\">while</h3><p>Aqui você está livre para fazer o que quiser. Também temos essa opção em outras linguagens.</p><pre><code class=\"language-ruby\">i = 0while i &lt; 10 do  puts i  i += 2 # pulando de dois em doisend</code></pre><p>Essa opção é um pouco mais verbosa comparada com as outras, mas tem seus usos.</p><p>Aqui está um exemplo mais real de como essa iteração pode ser usada.</p><pre><code class=\"language-ruby\">waiting_seconds = 0while stack.deploying?  logger.info(\"Waiting for deployment to complete\")  sleep waiting_seconds += 1end</code></pre><h3 id=\"until\">until</h3><p>Como disse, essa linguagem é linda. <code>until</code> é o contrário do <code>while</code>, ela executará enquanto a condição for <code>false</code>.</p><pre><code class=\"language-ruby\">until me.tired?  me.work_hardend</code></pre><h3 id=\"loop\">loop</h3><p>Se quiser ir para o infinito e além, use o <code>loop</code> para criar um <em>loop</em> infinito.</p><pre><code class=\"language-ruby\">loop do  # your code here..  break if your_conditionend</code></pre><h3 id=\"upto\">upto</h3><p>Muito claro o que isso faz pelo nome, expõe lindamente o que queremos, ir de um índice até outro, existe uma variação dessa forma que será o próximo tópico.</p><pre><code class=\"language-ruby\">1.upto(10) { |i| puts index }</code></pre><h3 id=\"downto\">downto</h3><pre><code class=\"language-ruby\">10.downto(1) { |i| puts index }</code></pre><h2 id=\"usando-iterações-como-se-você-tivesse-nascido-para-isso\">Usando Iterações como se Você Tivesse Nascido para Isso</h2><h3 id=\"enumerable\">Enumerable</h3><p>Leia a documentação do <a href=\"https://ruby-doc.org/core-2.7.0/Enumerable.html\">Enumerable</a>. Veja os métodos que o módulo oferece, brinque com eles no terminal iterativo (IRB). É aqui que você elevará suas habilidades para se tornar o grande programador que o mundo quer conhecer. Com esse módulo você não somente ira iterar sobre listas, mas poderá transformá-las, reduzí-las, fazer perguntas, filtrar etc.</p><h4 id=\"iterando-sobre-uma-fatia\">Iterando sobre uma fatia</h4><pre><code class=\"language-ruby\">[1, 2, 3, 4, 5, 6].each_slice(3) { |slice| puts slice }</code></pre><h4 id=\"transformando\">Transformando</h4><pre><code class=\"language-ruby\">[1, 2, 3, 4].map { |number| { number.to_s =&gt; number ** 2 } }</code></pre><h4 id=\"reduzindo\">Reduzindo</h4><pre><code class=\"language-ruby\">[1, 2, 3, 4].reduce({ numbers: [] }) do |hash, number|  hash[:numbers] &lt;&lt; number  hashend</code></pre><h4 id=\"questionando\">Questionando</h4><pre><code class=\"language-ruby\">[2, 4, 6, 8, 10].all?(&amp;:even?)</code></pre><pre><code class=\"language-ruby\">[1, 4, 3, 8, 9].select(&amp;:even?)</code></pre><h2 id=\"próximos-passos\">Próximos passos</h2><p>Essa pergunta no Stack Overflow para quem ficou com dúvidas sobre os últimos exemplos: <a href=\"https://stackoverflow.com/questions/1217088/what-does-mapname-mean-in-ruby\">What does map(&amp;:name) mean in Ruby?</a>.</p><p>Leia a documentação da classe <code>Array</code>, você encontrá vários métodos que você já viu no módulo <code>Enumerable</code>, porém encontrá muita coisa nova também: <a href=\"https://ruby-doc.org/core-2.7.0/Array.html\"><code>Array</code></a>.</p>",
            "url": "http://localhost:4000/2020/08/31/como-iterar-em-ruby",
            
            
            
            
            
            "date_published": "2020-08-31T00:00:00+01:00",
            "date_modified": "2020-08-31T00:00:00+01:00",
            
                "author":  {
                "name": "Matheus Silva",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/08/30/what-is-happening-with-my-block",
            "title": "What is Happening With my Block?",
            "summary": null,
            "content_text": "Do you know which tests are going to pass and which tests are going to fail in this test file?require \"minitest/autorun\"class TestBlocks &lt; Minitest::Test  def setup    @values = [\"a\", \"b\", \"c\", \"d\"]  end    def test_passing_a_block_with_do    assert @values.all? do |value|      false    end  end    def test_passing_a_block_with_do_surround_by_parentheses    assert(@values.all? do |value|      false    end)  end    def test_passing_a_block_with_braces    assert @values.all? { |value| false }  endendHow do you do in your code base? If you do like in test_passing_a_block_with_do it is bad news.test_passing_a_block_with_do is the only one which is going to pass, but why? I know you know, assert receives @values.all? do |value| as a block, then it thinks this block is true and that’s it. If you thought that, you’re almost right. Let’s see what is assert.# https://github.com/seattlerb/minitest/blob/6257210b7accfeb218b4388aaa36d3d45c5c41a5/lib/minitest/assertions.rb#L178def assert test, msg = nil  self.assertions += 1  unless test then    msg ||= \"Expected #{mu_pp test} to be truthy.\"    msg = msg.call if Proc === msg    raise Minitest::Assertion, msg  end  trueendSo, is test a Proc? What do you think?After debugging this method I know that test is true. Why is it true? The class is TrueClass, so it is a proper true. What is happening here?What is msg then? msg is the Proc then, right?(byebug) msgnilmsg is nil. Okay, it got the default value. Where is my block then? Well, there is only one place left now.(byebug) yieldfalseOk, false. The block I’m passing is returning false, is that the reason? If I change to:def test_passing_a_block_with_do  assert @values.all? do |value|    \"hello, world!\"  endendThen I have:(byebug) yield\"hello, world!\"Ahhhh, that was it.A mindful programmer would figure that out at first saw, there is no reason to think that the whole collection.all? do...end is going to be a single argument. However, I think it’s pretty easy to miss that, have you got it at first glance?",
            "content_html": "<p>Do you know which tests are going to pass and which tests are going to fail in this test file?</p><pre><code class=\"language-ruby\">require \"minitest/autorun\"class TestBlocks &lt; Minitest::Test  def setup    @values = [\"a\", \"b\", \"c\", \"d\"]  end    def test_passing_a_block_with_do    assert @values.all? do |value|      false    end  end    def test_passing_a_block_with_do_surround_by_parentheses    assert(@values.all? do |value|      false    end)  end    def test_passing_a_block_with_braces    assert @values.all? { |value| false }  endend</code></pre><p>How do you do in your code base? If you do like in <code>test_passing_a_block_with_do</code> it is bad news.</p><p><code>test_passing_a_block_with_do</code> is the only one which is going to pass, but why? I know you know, <code>assert</code> receives <code>@values.all? do |value|</code> as a block, then it thinks this block is true and that’s it. If you thought that, you’re almost right. Let’s see what is <code>assert</code>.</p><pre><code class=\"language-ruby\"># https://github.com/seattlerb/minitest/blob/6257210b7accfeb218b4388aaa36d3d45c5c41a5/lib/minitest/assertions.rb#L178def assert test, msg = nil  self.assertions += 1  unless test then    msg ||= \"Expected #{mu_pp test} to be truthy.\"    msg = msg.call if Proc === msg    raise Minitest::Assertion, msg  end  trueend</code></pre><p>So, is <code>test</code> a <code>Proc</code>? What do you think?</p><p>After debugging this method I know that <code>test</code> is <code>true</code>. Why is it <code>true</code>? The class is <code>TrueClass</code>, so it is a proper <code>true</code>. What is happening here?</p><p>What is <code>msg</code> then? <code>msg</code> is the <code>Proc</code> then, right?</p><pre><code class=\"language-ruby\">(byebug) msgnil</code></pre><p><code>msg</code> is <code>nil</code>. Okay, it got the default value. Where is my block then? Well, there is only one place left now.</p><pre><code class=\"language-ruby\">(byebug) yieldfalse</code></pre><p>Ok, <code>false</code>. The block I’m passing is returning <code>false</code>, is that the reason? If I change to:</p><pre><code class=\"language-ruby\">def test_passing_a_block_with_do  assert @values.all? do |value|    \"hello, world!\"  endend</code></pre><p>Then I have:</p><pre><code class=\"language-ruby\">(byebug) yield\"hello, world!\"</code></pre><p>Ahhhh, that was it.</p><p>A mindful programmer would figure that out at first saw, there is no reason to think that the whole <code>collection.all? do...end</code> is going to be a single argument. However, I think it’s pretty easy to miss that, have you got it at first glance?</p>",
            "url": "http://localhost:4000/2020/08/30/what-is-happening-with-my-block",
            
            
            
            
            
            "date_published": "2020-08-30T00:00:00+01:00",
            "date_modified": "2020-08-30T00:00:00+01:00",
            
                "author":  {
                "name": "Matheus Silva",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}